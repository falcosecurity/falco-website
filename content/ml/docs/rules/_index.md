| ശീർഷകം  | വെയ്റ്റ് |
| :-----: | :---: |
| നിയമങ്ങൾ |   3   |

ഒരു ഫാൽക്കോ *നിയമഫയൽ* മൂന്ന് തരത്തിലുള്ള ഘടകങ്ങളടങ്ങിയ ഒരു [YAML](http://www.yaml.org/start.html) ഫയലാണ്:

ഘടകം | വിവരണം 
:-------|:-----------
[Rules](#rules) | ഒരു അലേർട്ട് സൃഷ്ടിക്കപ്പെടേണ്ടതിനുള്ള *വ്യവസ്ഥകൾ*. അലേർട്ടിനോടൊപ്പം അയക്കുന്ന വിവരണാത്മക *ഔട്ട്പുട്ട് സ്ട്രിങ്ങിന്* ഒപ്പമുള്ളതാണ് ഒരു നിയമം. 
[Macros](#macros) | നിയമങ്ങൾക്കുള്ളിലും മറ്റ് മാക്രോകളിൽ പോലും വീണ്ടും ഉപയോഗിക്കാൻ കഴിയുന്ന നിയമവ്യവസ്ഥാസ്നിപ്പെറ്റുകൾ. സാധാരണയായ പാറ്റേണുകൾക്ക് പേരിടാനും നിയമങ്ങളിലെ ആവർത്തനങ്ങൾ ഒഴിവാക്കാനും മാക്രോകൾ ഒരു മാർഗ്ഗം നൽകുന്നു. 
[Lists](#lists) | നിയമങ്ങളിലും മാക്രോകളിലും അല്ലെങ്കിൽ മറ്റ് ലിസ്റ്റുകളിലും ഉൾപ്പെടുത്താവുന്ന ഇനങ്ങളുടെ ശേഖരങ്ങൾ. നിയമങ്ങളും മാക്രോകളും പോലെ, ലിസ്റ്റുകൾ ഫിൽട്ടറിങ് എക്സ്പ്രഷനുകളായി വിശകലനം ചെയ്യാനാകില്ല. 

## വേർഷനിങ്

കാലാകാലങ്ങളിൽ, ഫാൽക്കോയുടെ പഴയ പതിപ്പുകളുമായി തിരിച്ച് പൊരുത്തപ്പെടാത്ത നിയമങ്ങളുടെ ഫയൽ ഫോർമാറ്റിൽ ഞങ്ങൾ മാറ്റങ്ങൾ വരുത്തുന്നു. അതുപോലെ തന്നെ, ഫാൽ‌ക്കോയിൽ‌ ഏകീകരിക്കപ്പെടുത്തിയിട്ടുള്ള സിസ്ഡിഗ് ലൈബ്രറികൾ,‌ പുതിയ ഫിൽ‌റ്റർ‌ചെക്ക് ഫീൽ‌ഡുകൾ‌, ഓപ്പറേറ്ററുകൾ‌ മുതലായവ നിർ‌വ്വചിച്ചേക്കാം. തന്നിരിക്കുന്ന ഒരു കൂട്ടം നിയമങ്ങൾ‌ ആ സിസ്ഡിഗ് ലൈബ്രറികളിൽ നിന്നുള്ള ഫീൽ‌ഡുകൾ‌ / ഓപ്പറേറ്ററുകളെ ആശ്രയിച്ചിരിക്കുന്നുവെന്ന് ‌ സൂചിപ്പിക്കാൻ ഞങ്ങൾ‌ താൽ‌പ്പര്യപ്പെടുന്നു.

{{% pageinfo color="primary" %}}
ഫാൽക്കോ വേർഷൻ **0.14.0** അനുസരിച്ച്, ഫാൽക്കോ എഞ്ചിൻറെയും ഫാൽക്കോ നിയമഫയലിൻറെയും വ്യക്തമായ വേർഷനിങ്ങിനെ ഫാൽക്കോ നിയമങ്ങൾ പിന്തുണക്കുന്നു. 
{{% /pageinfo %}}

### ഫാൽക്കോ എഞ്ചിൻ വേർഷനിങ്

`falco` എക്സിക്ക്യൂട്ടബിളും  `falco_engine` C++ ഓബ്ജക്റ്റും ഇപ്പോൾ ഒരു വേർഷൻ നമ്പർ തിരിച്ച് നൽകുന്നതിനെ പിന്തുണക്കുന്നു. പ്രാരംഭ വേർഷൻ 2 എന്നതാണ് (മുൻപുള്ള വേർഷനുകൾ 1 ആയിരുന്നുവെന്ന് സൂചിപ്പിക്കുന്നു). നിയമഫയൽ ഫോർമാറ്റിൽ ഞങ്ങൾ മാറ്റങ്ങൾ വരുത്തുമ്പോഴോ അല്ലെങ്കിൽ ഫാൽക്കോയിലേക്ക് പുതിയ ഫിൽട്ടർചെക്ക് ഫീൽ‌ഡുകൾ‌ / ഓപ്പറേറ്ററുകളെ ഉൾപ്പെടുത്തുമ്പോഴോ ഞങ്ങൾ ഈ വേർഷൻ ഇൻക്രിമെൻറ് ചെയ്യും. 

### ഫാൽക്കോ നിയമഫയൽ വേർഷനിങ്

ഫാൽക്കോക്കൊപ്പം ഉൾപ്പെടുത്തിയിട്ടുള്ള ഫാൽക്കോ നിയമഫയൽ, ഈ നിയമഫയൽ വായിക്കാനാവശ്യമായ ഏറ്റവും കുറഞ്ഞ എഞ്ചിൻ വേർഷനെ വ്യക്തമാക്കുന്ന ഒരു പുതിയ ഉയർന്ന തരം ഓബ്ജക്റ്റ്, `required_engine_version: N`, ഉൾക്കൊള്ളുന്നു. ഉൾപ്പെടുത്തിയിട്ടില്ലെങ്കിൽ, നിയമഫയൽ വായിക്കുമ്പോൾ ഒരു വേർഷൻ പരിശോധനയും നടക്കുന്നില്ല. 

ഒരു നിയമഫയലിന് ഫാൽക്കോ എഞ്ചിൻ വേർഷനേക്കാൾ വലിയ ഒരു `engine_version` ഉണ്ടെങ്കിൽ, നിയമഫയൽ ലോഡാവുകയും ഒരു പിശക് തിരിച്ചുവരുകയും ചെയ്യുന്നു.

## നിയമങ്ങൾ

ഒരു ഫാൽക്കോ നിയമം ഇനി പറയുന്ന കീകൾ അടങ്ങിയ ഒരു നോഡ് ആണ്:

കീ | ആവശ്യകത | വിവരണം | ഡീഫോൾട്ട് 
:---|:---------|:------------|:-------
`rule` | ഉണ്ട് | നിയമത്തിനായുള്ള ഒരു ചെറിയ, അദ്വിതീയമായ പേര് |
`condition` | ഉണ്ട് | ഇവൻറുകൾ നിയമവുമായി പൊരുത്തപ്പെടുന്നുണ്ടോ എന്ന് പരിശോധിക്കാൻ അവക്കെതിരെ പ്രയോഗിക്കുന്ന ഒരു ഫിൽട്ടറിങ് എക്സ്പ്രഷൻ. |
`desc` | ഉണ്ട് | നിയമം കണ്ടുപിടിക്കുന്നതെന്തോ അതിൻറെ ദീർഘമായ വിവരണം. |
`output` | ഉണ്ട് | സിസ്ഡിഗ് [output format syntax](http://www.sysdig.com/wiki/sysdig-user-guide/#output-formatting) നെ പിന്തുടർന്ന്, ഒരു പൊരുത്തപ്പെടുന്ന ഇവൻറ് സംഭവിക്കുകയാണെങ്കിൽ ഔട്ട്പുട്ട് ആവേണ്ട മെസ്സേജ് വ്യക്തമാക്കുന്നു. |
`priority` | ഉണ്ട് | ഇവൻറിൻറെ തീവ്രതയുടെ ഒരു കേസ്-ഇൻസെൻസിറ്റീവ് പ്രതിനിധീകരണം. ഇനി പറയുന്നവയിൽ ഒന്നായിരിക്കണം: `emergency`, `alert`, `critical`, `error`, `warning`, `notice`, `informational`, `debug`. |
`exceptions` | ഇല്ല | നിയമം ഒരു അലേർട്ട് ജനറേറ്റ് ചെയ്യാതിരിക്കാൻ കാരണമാകുന്ന ഒരു കൂട്ടം  [exceptions](/docs/rules/exceptions). |
`enabled` | ഇല്ല | `false` ആയിട്ട് സെറ്റ് ചെയ്താൽ, ഒരു നിയമം ലോഡുചെയ്യുകയോ ഏതെങ്കിലും ഇവൻറുകളുമായി പൊരുത്തപ്പെടുകയോ ചെയ്യില്ല. | `true`
`tags` | ഇല്ല | നിയമത്തിൽ പ്രയോഗിക്കുന്ന ടാഗുകളുടെ ഒരു ലിസ്റ്റ് (ഇതിനെ കുറിച്ച് കൂടുതൽ [below](#tags) എന്നിടത്ത്). |
`warn_evttypes` | ഇല്ല | `false` ആയിട്ട് സെറ്റ് ചെയ്താൽ, നിയമത്തിന് ഒരു ഇവൻറ് ടൈപ്പ് ഇല്ലാത്തതിനെ സംബന്ധിക്കുന്ന മുന്നറിയിപ്പുകളെ ഫാൽക്കോ അടിച്ചമർത്തുന്നു (ഇതിനെ കുറിച്ച് കൂടുതൽ [below](#rule-condition-best-practices) എന്നിടത്ത്). | `true`
`skip-if-unknown-filter` | ഇല്ല | `true` ആയിട്ട് സെറ്റ് ചെയ്താൽ, നിയമവ്യവസ്ഥകൾ ഒരു ഫിൽട്ടർചെക്ക് ഉൾക്കൊള്ളുന്നുവെങ്കിൽ, ഉദാ: `fd.some_new_field`, അത് ഫാൽക്കോയുടെ ഈ വേർഷന് പരിചിതമല്ല, ഫാൽക്കോ നിയമം നിശബ്ദമായി അംഗീകരിക്കുന്നു, പക്ഷേ അത് നടപ്പാക്കുന്നില്ല;  `false` ആയിട്ടാണ് സെറ്റ് ചെയ്യുന്നതെങ്കിൽ, ഫാൽക്കോ ഒരു പിശക് റിപ്പോർട്ട് ചെയ്യുകയും അപരിചിതമായ ഫിൽട്ടർചെക്ക് കണ്ടെത്തുമ്പോൾ നിലനിൽക്കുകയും ചെയ്യുന്നു. | `false`

## വ്യവസ്ഥകൾ

ഒരു നിയമത്തിൻറെ പ്രധാനഭാഗം *വ്യവസ്ഥാ* ഫീൽഡാണ്. ഒരു വ്യവസ്ഥ എന്നത് ലളിതമായി സിസ്ഡിഗ് [filter syntax](http://www.sysdig.com/wiki/sysdig-user-guide/#filtering) ഉപയോഗിച്ച് എക്സ്പ്രസ് ചെയ്യുന്ന ഒരു ബൂളിയൻ പ്രെഡിക്കേറ്റ് ആണ്. ഏതൊരു സിസ്ഡിഗ് ഫിൽട്ടറും സാധുവായ ഒരു ഫാൽക്കോ വ്യവസ്ഥയാണ് (ചില ഒഴിവാക്കിയ സിസ്റ്റം കോളുകൾ ഒഴികെ, താഴെ ചർച്ചചെയ്തിരിക്കുന്നു). കൂടാതെ, ഫാൽക്കോ വ്യവസ്ഥകൾക്ക് മാക്രോ ടേംസ് ഉൾക്കൊള്ളാനാകും (സിസ്ഡിഗ് സിൻടാക്സിൽ ഈ കഴിവ് ഇല്ല).

ഒരു ബാഷ് ഷെൽ ഒരു കണ്ടെയ്നറിനകത്ത് റൺ ചെയ്യുമ്പോഴെല്ലാം അലേർട്ട് ചെയ്യുന്ന ഒരു വ്യവസ്ഥയുടെ ഉദാഹരണം ഇതാ:

```
container.id != host and proc.name = bash
```

 ആദ്യത്തെ ക്ലോസ് ഇവൻറ് കണ്ടെയ്നറിൽ സംഭവിച്ചിട്ടുണ്ടോ എന്ന് പരിശോധിക്കുന്നു (സിസ്ഡിഗ് ഇവൻറുകൾക്ക് ഒരു സാധാരണ ഹോസ്റ്റിലാണ് ഇവൻറ് സംഭവിക്കുന്നത് എങ്കിൽ  `"host"` എന്നതിന് തുല്യമായ ഒരു `container` ഫീൽഡ് ഉണ്ട്). രണ്ടാമത്തെ ക്ലോസ് പ്രക്രിയയുടെ പേര് `bash` എന്നാകുന്നത് പരിശോധിക്കുന്നു. ഈ വ്യവസ്ഥയിൽ ഒരു സിസ്റ്റം കോൾ ഉള്ള ക്ലോസ് പോലും ഉൾപ്പെടുന്നില്ല എന്നത് ശ്രദ്ധിക്കുക! ഇവൻറ് മെറ്റാഡാറ്റ മാത്രമേ അത് പരിശോധിക്കുന്നുള്ളൂ. അതുകാരണം, ഒരു ബാഷ് ഷെൽ ഒരു കണ്ടെയ്നറിൽ ആരംഭിക്കുന്നുവെങ്കിൽ, ഫാൽക്കോ ആ ഷെൽ നടത്തുന്ന എല്ലാ സിസ്കോളിനും ഇവൻറുകളെ ഔട്ട്പുട്ട് ചെയ്യുന്നു.

മുകളിലെ വ്യവസ്ഥ ഉപയോഗിച്ചുകൊണ്ടുള്ള ഒരു പൂർണ്ണനിയമം ഇതാകാം:

```yaml
- rule: shell_in_container
  desc: ഒരു കണ്ടെയ്നറിനകത്തുള്ള ഷെൽ പ്രവർത്തനം ശ്രദ്ധിക്കുന്നു
  condition: container.id != host and proc.name = bash
  output: ഒരു കണ്ടെയ്നറിനകത്തുള്ള ഷെൽ (user=%user.name container_id=%container.id container_name=%container.name shell=%proc.name parent=%proc.pname cmdline=%proc.cmdline)
  priority: WARNING
```

## മാക്രോകൾ

മുകളിൽ പറഞ്ഞതുപോലെ,  നിയമങ്ങളുടെ പൊതുവായ ഉപഭാഗങ്ങൾ പുനരുപയോഗിക്കാൻ തക്കവണ്ണം നിർവചിക്കുന്നതിന് മാക്രോകൾ ഒരു മാർഗ്ഗം ലഭ്യമാക്കുന്നു. ഒരു ലളിതമായ ഉദാഹരണത്തിന്, കണ്ടെയ്നറുകളിൽ സംഭവിക്കുന്ന ഇവൻറുകൾക്കായി നമുക്ക് നിരവധി നിയമങ്ങളുണ്ടായിരുന്നുവെങ്കിൽ, നമ്മൾ ഒരു `in_container` മാക്രോ നിർവചിച്ചേക്കാം:

```yaml
- macro: in_container
  condition: container.id != host
```

ഈ മാക്രോ നിർവചിച്ചതുകൊണ്ട്,  നമുക്കിനി മുകളിലുള്ള നിയമത്തിൻറെ വ്യവസ്ഥ `in_container and proc.name = bash` എന്നായി തിരുത്തിയെഴുതാനാകും.

നിയമങ്ങളുടെയും മാക്രോകളുടെയും കൂടുതൽ ഉദാഹരണങ്ങൾക്ക്, [default macros](./default-macros) എന്നതിലെ ഡോക്യുമെൻറേഷനോ അല്ലെങ്കിൽ `rules/falco_rules.yaml` ഫയലോ നോക്കുക.

## ലിസ്റ്റുകൾ

നിങ്ങൾക്ക് നിയമങ്ങളിലോ, മാക്രോകളിലോ, അല്ലെങ്കിൽ മറ്റ് ലിസ്റ്റുകളിൽ പോലും ഉൾപ്പെടുത്താവുന്ന ഇനങ്ങളുടെ പേരുകളുള്ള ശേഖരങ്ങളാണ് *ലിസ്റ്റുകൾ*. ലിസ്റ്റുകളെ ഫിൽട്ടറിങ് എക്സ്പ്രഷനുകളായി പാർസുചെയ്യാൻ *കഴിയില്ലെന്ന്* ദയവായി ശ്രദ്ധിക്കുക. ഓരോ ലിസ്റ്റ് നോഡിനും ഇനി പറയുന്ന കീകളുണ്ട്:

Key | Description
:---|:-----------
`list` | ലിസ്റ്റിനായുള്ള അദ്വിതീയമായ ഒരു പേര് (സ്ലഗ് എന്നത് പോലെ) 
`items` | മൂല്യങ്ങളുടെ ലിസ്റ്റ് 

ചില ഉദാഹരണലിസ്റ്റുകളും അവയെ ഉപയോഗിക്കുന്ന ഒരു മാക്രോയും ഇതാ:

```yaml
- list: shell_binaries
  items: [bash, csh, ksh, sh, tcsh, zsh, dash]

- list: userexec_binaries
  items: [sudo, su]

- list: known_binaries
  items: [shell_binaries, userexec_binaries]

- macro: safe_procs
  condition: proc.name in (known_binaries)
```

ഒരു ലിസ്റ്റ് റഫർ ചെയ്യുന്നത് മാക്രോയിലോ നിയമത്തിലോ അല്ലെങ്കിൽ ലിസ്റ്റിലോ ഉള്ള ലിസ്റ്റ് ഇനങ്ങൾ ഇൻസർട്ട് ചെയ്യുന്നു.

ലിസ്റ്റുകൾക്ക് മറ്റ് ലിസ്റ്റുകൾ ഉൾക്കൊള്ളാൻ *കഴിയും*.


## ലിസ്റ്റുകൾ, നിയമങ്ങൾ, മാക്രോകൾ എന്നിവയുമായി അനുബന്ധിപ്പിക്കുന്നത്

നിങ്ങൾ ഒന്നിലധികം ഫാൽക്കോ നിയമഫയലുകൾ ഉപയോഗിക്കുന്നുണ്ടെങ്കിൽ, നിങ്ങൾക്ക് നിലവിലുള്ള ഒരു ലിസ്റ്റിലേക്കോ നിയമത്തിലേക്കോ അല്ലെങ്കിൽ മാക്രോയിലേക്കോ പുതിയ ഇനങ്ങൾ അനുബന്ധിപ്പിക്കാൻ താൽപ്പര്യമുണ്ടാകാം. അത് ചെയ്യുന്നതിന്, അതേ പേരിൽ ഒരു നിലവിലുള്ള ഇനമായി ഒരു ഇനം നിർവചിക്കുകയും ഒരു  `append: true` വിശേഷണം ലിസ്റ്റിലേക്ക് ചേർക്കുകയും ചെയ്യുക. ലിസ്റ്റുകൾ അനുബന്ധിപ്പിക്കുമ്പോൾ, ഇനങ്ങൾ ലിസ്റ്റിൻറെ **അവസാനത്തേക്കാണ്** ചേർക്കുന്നത്. നിയമങ്ങൾ/മാക്രോകൾ അനുബന്ധിപ്പിക്കുമ്പോൾ, അധികമുള്ള ടെക്സ്റ്റ് വ്യവസ്ഥയിലേക്ക് അനുബന്ധിപ്പിക്കുന്നു: നിയമത്തിൻറെ/മാക്രോയുടെ ഫീൽഡ്.

ലിസ്റ്റുകൾ, നിയമങ്ങൾ, മാക്രോകൾ എന്നിവയുമായി അനുബന്ധിപ്പിക്കുമ്പോൾ, നിയമക്രമീകരണഫയലുകളുടെ ക്രമം ബാധകമാണ് എന്നത് ശ്രദ്ധിക്കുക! ഉദാഹരണത്തിന്, ഒരു നിലവിലുള്ള ഡീഫോൾട്ട് നിയമവുമായാണ് നിങ്ങൾ അനുബന്ധിപ്പിക്കുന്നത് എങ്കിൽ (ഉദാ: `Terminal shell in container`), നിങ്ങളുടെ കസ്റ്റം ക്രമീകരണഫയൽ (ഉദാ: `/etc/falco/rules.d/custom-rules.yaml`) ഡീഫോൾട്ട് ക്രമീകരണഫയലിന് (`/etc/falco/falco_rules.yaml`) **ശേഷമാണ്** ലോഡുചെയ്യുന്നത് എന്ന് നിങ്ങൾ ഉറപ്പുവരുത്തേണ്ടതുണ്ട്. ഇത് ഒന്നിലധികം `-r` പാരാമീറ്ററുകൾ ഉപയോഗിച്ച് ശരിയായ ക്രമത്തിൽ `rules_file` വഴി നേരിട്ട് ഫാൽക്കോ ക്രമീകരണഫയലിനകത്തേക്ക് ക്രമീകരിക്കാവുന്നതാണ് (`falco.yaml`) അല്ലെങ്കിൽ നിങ്ങൾ ഔദ്യോഗിക ഹെൽം ചാർട്ടാണ് ഉപയോഗിക്കുന്നതെങ്കിൽ  `falco.rulesFile` മൂല്യം വഴിയും.

### ഉദാഹരണങ്ങൾ

താഴെ തന്നിരിക്കുന്ന ഉദാഹരണങ്ങളിൽ, ഒരെണ്ണം `falco -r /etc/falco/falco_rules.yaml -r /etc/falco/falco_rules.local.yaml` വഴി ഫാൽക്കോ റൺ ചെയ്യുന്നുവെന്നോ ,അല്ലെങ്കിൽ falco.yaml എന്നതിൽ `rules_file` ന് വേണ്ടി  `/etc/falco/falco.yaml` ഒന്നാമതും `/etc/falco/falco_rules.local.yaml` രണ്ടാമതുമായുള്ള  ഡീഫോൾട്ട് എൻട്രികളുണ്ട് എന്നോ അനുമാനിക്കുന്നു.

#### ലിസ്റ്റുകളുമായി അനുബന്ധിപ്പിക്കുന്നത്

ലിസ്റ്റുകളുമായി അനുബന്ധിപ്പിക്കുന്നതിൻറെ ഒരു ഉദാഹരണം ഇതാ:

**/etc/falco/falco_rules.yaml**

```yaml
- list: my_programs
  items: [ls, cat, pwd]

- rule: my_programs_opened_file
  desc: പ്രോഗ്രാമുകളുടെ ഒരു കൂട്ടം ഒരു ഫയൽ ഓപ്പൺ ചെയ്യുമ്പോൾ ട്രാക്ക് ചെയ്യുന്നു
  condition: proc.name in (my_programs), evt.type=open എന്നിവ
  output: ഒരു ട്രാക്ക് ചെയ്ത പ്രോഗ്രാം ഒരു ഫയൽ ഓപ്പൺ ചെയ്തു  (user=%user.name command=%proc.cmdline file=%fd.name)
  priority: INFO
```

**/etc/falco/falco_rules.local.yaml**

```yaml
- list: my_programs
  append: true
  items: [cp]
```

 `my_programs_opened_file` എന്ന നിയമം `ls`, `cat`, `pwd`, അല്ലെങ്കിൽ `cp` എന്നിവയിൽ ഏതെങ്കിലും ഒന്ന് ഒരു ഫയൽ ഓപ്പൺ ചെയ്യുമ്പോഴെല്ലാം ട്രിഗർ ചെയ്യുന്നു.

#### മാക്രോകളുമായി അനുബന്ധിപ്പിക്കുന്നത്

മാക്രോകളുമായി അനുബന്ധിപ്പിക്കുന്നതിൻറെ ഒരു ഉദാഹരണം ഇതാ:

**/etc/falco/falco_rules.yaml**

```yaml
- macro: access_file
  condition: evt.type=open

- rule: program_accesses_file
  desc: പ്രോഗ്രാമുകളുടെ ഒരു കൂട്ടം ഒരു ഫയൽ ഓപ്പൺ ചെയ്യുമ്പോൾ ട്രാക്ക് ചെയ്യുന്നു
  condition: proc.name in (cat, ls) and (access_file)
  output: ഒരു ട്രാക്ക് ചെയ്ത പ്രോഗ്രാം ഒരു ഫയൽ ഓപ്പൺ ചെയ്തു (user=%user.name command=%proc.cmdline file=%fd.name)
  priority: INFO
```

**/etc/falco/falco_rules.local.yaml**
```yaml
- macro: access_file
  append: true
  condition: or evt.type=openat
```

 `program_accesses_file` നിയമം `ls`/`cat` എന്നിവയിലൊരെണ്ണം `open`/`openat` എന്നത് ഒരു ഫയലിൽ ഉപയോഗിക്കുമ്പോൾ ട്രിഗർ ചെയ്യുന്നു. 

#### നിയമങ്ങളുമായി അനുബന്ധിപ്പിക്കുന്നത്

നിയമങ്ങളുമായി അനുബന്ധിപ്പിക്കുന്നതിൻറെ ഒരു ഉദാഹരണം ഇതാ:

**/etc/falco/falco_rules.yaml**

```yaml
- rule: program_accesses_file
  desc: പ്രോഗ്രാമുകളുടെ ഒരു കൂട്ടം ഒരു ഫയൽ ഓപ്പൺ ചെയ്യുമ്പോൾ ട്രാക്ക് ചെയ്യുന്നു
  condition: (cat, ls), evt.type=open എന്നിവയിലെ proc.name 
  output: ഒരു ട്രാക്ക് ചെയ്ത പ്രോഗ്രാം ഒരു ഫയൽ ഓപ്പൺ ചെയ്തു (user=%user.name command=%proc.cmdline file=%fd.name)
  priority: INFO
```

**/etc/falco/falco_rules.local.yaml**

```yaml
- rule: program_accesses_file
  append: true
  condition: and not user.name=root
```
 `program_accesses_file` നിയമം നിയമം `ls`/`cat` എന്നിവയിലൊരെണ്ണം `open`എന്നത് ഒരു ഫയലിൽ ഉപയോഗിക്കുമ്പോൾ ട്രിഗർ ചെയ്യുന്നു, പക്ഷേ ഉപയോക്താവ് റൂട്ട് ആണെങ്കിൽ ഇല്ല.

### നിയമ/മാക്രോ അനുബന്ധവും ലോജിക്കൽ ഓപ്പറേറ്ററുകളുമായി ബന്ധപ്പെട്ട Gotchas

നിയമങ്ങളും മാക്രോകളും അനുബന്ധിപ്പിക്കുമ്പോൾ, രണ്ടാമത്തെ നിയമത്തിൻറെ/ മാക്രോയുടെ ടെക്സ്റ്റ് ലളിതമായി ആദ്യത്തെ നിയമത്തിൻറെ/ മാക്രോയുടെ വ്യവസ്ഥയിലേക്ക് കൂട്ടിച്ചേർക്കുന്നു എന്ന് ഓർമ്മിക്കുക. ഒറിജിനൽ നിയമത്തിന്/  മാക്രോക്ക് സംഭവ്യമായ അവ്യക്തമായ ലോജിക്കൽ ഓപ്പറേറ്ററുകളുണ്ടെങ്കിൽ ഇത് ഉദ്ദേശിക്കാത്ത ഫലങ്ങളിൽ പര്യവസാനിക്കാം. ഇതാ ഒരു ഉദാഹരണം:

```yaml
- rule: my_rule
  desc: ...
  condition: evt.type=open and proc.name=apache
  output: ...

- rule: my_rule
  append: true
  condition: or proc.name=nginx
```

`proc.name=nginx` എന്നത് വ്യാഖ്യാനിക്കേണ്ടത് `and proc.name=apache`എന്നതിന് ആപേക്ഷികമായി apache/nginx എന്നിവയെ ഫയലുകൾ ഓപ്പൺ ചെയ്യാൻ അനുവദിക്കുന്നതിനാണോ, അല്ലെങ്കിൽ `evt.type=open` എന്നതിന് ആപേക്ഷികമായി apacheയെ ഫയലുകൾ ഓപ്പൺ ചെയ്യാൻ അനുവദിക്കുകയോ  അഥവാ nginxനെ എന്തെങ്കിലും ചെയ്യാൻ അനുവദിക്കുകയോ ചെയ്യുന്നതിനാണോ?

ഇത്തരം സാഹചര്യങ്ങളിൽ, സാധ്യമാകുമ്പോൾ പാരെൻതെസിസ് ഉള്ള ഒറിജിനൽ വ്യവസ്ഥയിലുള്ള ലോജിക്കൽ ഓപ്പറേറ്ററുകൾ സ്ക്കോപ്പ് ചെയ്യുന്നത് ഉറപ്പുവരുത്തുക, അല്ലെങ്കിൽ സാധ്യമല്ലാത്തപ്പോൾ വ്യവസ്ഥകൾ അനുബന്ധിപ്പിക്കുന്നത് ഒഴിവാക്കുക.

## ഡീഫോൾട്ട് നിയമങ്ങൾ അപ്രാപ്തമാക്കുക

ഫാൽക്കോ വളരെ പ്രബലമായ ഒരു ഡീഫോൾട്ട് നിയമഗണം ലഭ്യമാക്കുന്നുണ്ടെങ്കിലും, ചില സമയങ്ങളിൽ നിങ്ങളുടെ പരിതസ്ഥിതിയിൽ അവ ശരിയാംവിധം പ്രവർത്തിക്കാതിരിക്കുമ്പോൾ നിങ്ങൾക്ക് ഈ ഡീഫോൾട്ട് നിയമങ്ങൾ അപ്രാപ്തമാക്കേണ്ടിവരും. ഭാഗ്യവശാൽ, ഇത് ചെയ്യാൻ ഫാൽക്കോ നിങ്ങൾക്ക് നിരവധി സാധ്യതകൾ വാഗ്ദാനം ചെയ്യുന്നു.

### നിലവിലുള്ള മാക്രോകൾ വഴി

ഭൂരിഭാഗം ഡീഫോൾട്ട് നിയമങ്ങളും ഇതിനകം തന്നെ നിയമവ്യവസ്ഥകളുടെ ഭാഗമായുള്ള ഒരു തരം `consider_*` മാക്രോകൾ വാഗ്ദാനം ചെയ്യുന്നു. ഈ `consider_*` മാക്രോകൾ സാധാരണയായി സജ്ജീകരിക്കുന്നത്  ബന്ധപ്പെട്ട നിയമത്തെ അടിസ്ഥാനപരമായി പ്രാപ്തമാക്കുകയോ അപ്രാപ്തമാക്കുകയോ ചെയ്യുന്ന`(never_true)` അല്ലെങ്കിൽ `(always_true)` എന്നിവയിലേക്കാണ്. ഇപ്പോൾ നിങ്ങൾക്ക് ഡീഫോൾട്ട് ആയി അപ്രാപ്തമായിരിക്കുന്ന ഒരു നിയമത്തെ പ്രാപ്തമാക്കണമെന്നുണ്ടെങ്കിൽ, (ഉദാ: `Unexpected outbound connection destination`), നിങ്ങൾക്ക് നിയമത്തിൻറെ `consider_*` മാക്രോ(ഈ സാഹചര്യത്തിൽ `consider_all_outbound_conns` ) നിങ്ങളുടെ കസ്റ്റം ഫാൽക്കോ ക്രമീകരണത്തിനുള്ളിൽ ഓവർറൈഡ് ചെയ്താൽ മതി. 

നിങ്ങളുടെ കസ്റ്റം ഫാൽക്കോ ക്രമീകരണത്തിനുള്ള ഉദാഹരണം (`(always_true)` വ്യവസ്ഥ ശ്രദ്ധിക്കുക):
```yaml
- macro: consider_all_outbound_conns
  condition: (always_true)
```

വ്യക്തമാക്കിയ ക്രമീകരണഫയലിൻറെ ക്രമം ബാധകമാണ് എന്നത് ദയവായി വീണ്ടും ശ്രദ്ധിക്കുക! അതേ പേരിൽ അവസാനം നിർവചിക്കപ്പെട്ട മാക്രോ വിജയിക്കുന്നു.

### ഫാൽക്കോ പാരാമീറ്ററുകൾ വഴി

ഏതൊക്കെ ഡീഫോൾട്ട് നിയമങ്ങളാണ് പ്രാപ്തമാക്കേണ്ടത്/ഉപയോഗിക്കേണ്ടത് എന്നും ഏതൊക്കെ വേണ്ട എന്നും പരിമിതപ്പെടുത്താൻ ഫാൽക്കോ ഇനി പറയുന്ന പാരാമീറ്ററുകൾ വാഗ്ദാനം ചെയ്യുന്നു: 
```bash
-D <substring>                 <substring> എന്ന സബ്സ്ട്രിങ്ങ് ഉള്ള പേരുകളുള്ള ഏത് നിയമവും അപ്രാപ്തമാക്കുക. ഒന്നിലധികം തവണ വ്യക്തമാക്കാൻ കഴിയും.

-T <tag>                      tag=<tag> എന്ന ടാഗുള്ള ഏത് നിയമവും അപ്രാപ്തമാക്കുക. ഒന്നിലധികം തവണ വ്യക്തമാക്കാൻ കഴിയും.
                               -t ഉപയോഗിച്ച് വ്യക്തമാക്കാൻ കഴിയില്ല.

-t <tag>                      ആ നിയമങ്ങൾ tag=<tag> എന്ന ടാഗുപയോഗിച്ച് മാത്രം വ്യക്തമാക്കുക. ഒന്നിലധികം തവണ വ്യക്തമാക്കാൻ കഴിയും.
                               -T/-D ഉപയോഗിച്ച് വ്യക്തമാക്കാൻ കഴിയില്ല.
```

നിങ്ങൾ ഔദ്യോഗിക ഹെൽം ചാർട്ട് വഴിയാണ് ഫാൽക്കോയെ വിന്യസിക്കുന്നതെങ്കിൽ, ഈ പാരാമീറ്ററുകൾ ഹെൽം ചാർട്ട് മൂല്യങ്ങളായും (`extraArgs`) വ്യക്തമാക്കാവുന്നതാണ്.

### കസ്റ്റം നിയമനിർവചനം വഴി

അവസാനമായി എന്നാൽ ഒട്ടും നിസ്സാരമല്ലാതെ,`append: true` and `enabled: false` നിയമസവിശേഷതകളുടെ ഒരു സമ്മിശ്രണം ഉപയോഗിച്ച്, ഡീഫോൾട്ട് ആയി പ്രാപ്തമാക്കിവെച്ചിരിക്കുന്ന ഒരു നിയമത്തെ നിങ്ങൾക്ക് അപ്രാപ്തമാക്കാവുന്നതാണ്. 
ഡീഫോൾട്ട് വ്യവസ്ഥയിൽ ഒരു `consider_*` മാക്രോ ലഭ്യമാക്കാത്ത നിയമങ്ങൾക്ക് ഇത് വിശേഷിച്ചും ഉപകാരപ്രദമാണ്.

ഡീഫോൾട്ട് ക്രമീകരണഫയലിന് ശേഷമാണ് കസ്റ്റം ക്രമീകരണഫയൽ ലോഡുചെയ്യുന്നത് എന്ന് ഉറപ്പുവരുത്തുക. ഒന്നിലധികം `-r` പാരാമീറ്ററുകൾ ഉപയോഗിച്ച്, `rules_file` എന്നതിലൂടെ നേരിട്ട് `falco.yaml` എന്ന ഫാൽക്കോ ക്രമീകരണഫയലിനുള്ളിൽ  നിങ്ങൾക്ക് ശരിയായ ക്രമത്തിൽ ക്രമീകരിക്കാവുന്നതാണ്. നിങ്ങൾ ഔദ്യോഗിക ഹെൽം ചാർട്ടാണ് ഉപയോഗിക്കുന്നത് എന്നാൽ, ക്രമം `falco.rulesFile` മൂല്യം ഉപയോഗിച്ച്  ക്രമീകരിക്കുക.

ഉദാഹരണത്തിന് `/etc/falco/falco_rules.yaml` എന്നതിൽ `User mgmt binaries` ഡീഫോൾട്ട് നിയമം അപ്രാപ്തമാക്കുന്നതിന് /etc/falco/rules.d/custom-rules.yaml` എന്നതിൽ ഒരു കസ്റ്റം നിയമം നിർവചിക്കുക:

```yaml
- rule: User mgmt binaries
  append: true
  enabled: false
```

 {{% pageinfo color="warning" %}}
ഈ സവിശേഷതയിൽ ഞങ്ങൾ നോക്കിക്കൊണ്ടിരിക്കുന്ന ഒരു തകരാറുണ്ട്. `enabled: false`  എന്നത് പ്രവർത്തിക്കുന്നില്ലെങ്കിൽ, പകരമായി നിങ്ങൾക്ക് ഇനി പറയുന്ന പരിഹാരമാർഗ്ഗം ഉപയോഗിക്കാം:

 ```yaml
 - rule: User mgmt binaries
   condition: and (never_true)
   append: true
 ```
 {{% /pageinfo %}}


## നിയമമുൻഗണനകൾ

എല്ലാ ഫാൽക്കോ നിയമത്തിനും എത്രത്തോളം പ്രധാനമാണ് ഒരു നിയമലംഘനം എന്ന് സൂചിപ്പിക്കുന്ന ഒരു മുൻഗണനയുണ്ട്. മെസ്സേജ്/JSON ഔട്ട്പുട്ട്/മുതലായവയിലാണ് മുൻഗണന ഉൾപ്പെടുത്തിയിരിക്കുന്നത്. ലഭ്യമായ മുൻഗണനകൾ ഇതാ:

* `EMERGENCY`
* `ALERT`
* `CRITICAL`
* `ERROR`
* `WARNING`
* `NOTICE`
* `INFORMATIONAL`
* `DEBUG`

നിയമങ്ങൾക്ക് മുൻഗണനകൾ ഏൽപ്പിക്കുന്നതിന് ഉപയോഗിക്കുന്ന പൊതുവായ മാർഗ്ഗനിർദ്ദേശങ്ങൾ ഇനി പറയുന്നവയാണ്:

* ഒരു നിയമം എഴുതുന്ന സ്ഥിതിയുമായി ബന്ധപ്പെട്ടതാണെങ്കിൽ (ഉദാ: filesystem, മുതലായവ), അതിൻറെ മുൻഗണന `ERROR` എന്നതാണ്.
* ഒരു നിയമം സ്ഥിതിയുടെ അനധികൃത വായനയുമായി ബന്ധപ്പെട്ടതാണെങ്കിൽ (ഉദാ: സെൻസിറ്റീവ് ഫയലുകളുടെ വായന,മുതലായവ.), അതിൻറെ മുൻഗണന `WARNING` എന്നതാണ്.
* ഒരു നിയമം ഒരു അപ്രതീക്ഷിത പെരുമാറ്റവുമായി ബന്ധപ്പെട്ടതാണെങ്കിൽ (ഒരു കണ്ടെയ്നറിൽ ഒരു അപ്രതീക്ഷിത ഷെൽ സ്പോൺ ചെയ്യുന്നത്, അപ്രതീക്ഷിതമായ ഒരു നെറ്റ്വർക്ക് കണക്ഷൻ ഓപ്പൺ ചെയ്യുന്നത്, മുതലായവ.), അതിൻറെ മുൻഗണന `NOTICE` ആണ്.
* ഒരു നിയമം നല്ല പ്രവൃത്തികൾക്കെതിരെ പെരുമാറുന്നതുമായി ബന്ധപ്പെട്ടതാണെങ്കിൽ (അപ്രതീക്ഷിത പ്രിവിലേജ്ഡ് കണ്ടെയ്നറുകൾ, containers with sensitive mounts സെൻസിറ്റീവ് മൌണ്ടുകളോടുകൂടിയ കണ്ടെയ്നറുകൾ, ഇൻററാക്റ്റീവ് കമാൻഡുകളെ റൂട്ട് ആയി റൺ ചെയ്യുന്നത്), അതിൻറെ മുൻഗണ `INFO` എന്നതാണ്.

`DEBUG` എന്നതിന് മുൻഗണനയുള്ള തീർത്തും FP-prone ആയ "Run shell untrusted" എന്ന നിയമം വ്യത്യസ്തമാണ്.

## നിയമടാഗുകൾ{#tags}

0.6.0 പ്രകാരം,ബന്ധപ്പെട്ട നിയമങ്ങളുടെ കൂട്ടങ്ങളിലേക്ക് നിയമഗണത്തെ തരംതിരിക്കാൻ ഉപയോഗിക്കുന്ന ഒരു ഓപ്ഷണൽ *ടാഗുകളുടെ* ഗണം നിയമങ്ങൾക്കുണ്ട്. ഇതാ ഒരു ഉദാഹരണം:

```yaml
- rule: പ്രിവിലേജ്ഡ് കണ്ടെയ്നറാൽ ഓപ്പൺ ചെയ്ത ഫയൽ
  desc: പ്രിവിലേജ്ഡ് കണ്ടെയ്നറാൽ ഓപ്പൺ ചെയ്ത എന്തും.പരിചിതമായ വിശ്വാസയോഗ്യമായ ചിത്രങ്ങൾക്ക് എക്സെപ്ഷനുകൾ ഉണ്ട്.
  condition: (open_read or open_write) കണ്ടെയ്നർ, container.privileged=true എന്നിവ, trusted_containers ഇല്ല
  output: പ്രിവിലേജ്ഡ് കണ്ടെയ്നറാൽ വായിക്കാനോ എഴുതാനോ ഓപ്പൺ ചെയ്ത ഫയൽ (user=%user.name command=%proc.cmdline %container.info file=%fd.name)
  priority: WARNING
  tags: [container, cis]
```

ഈ സാഹചര്യത്തിൽ, "File Open by Privileged Container" എന്ന നിയമത്തിന് "container", "cis" എന്നീ ടാഗുകൾ നൽകിയിരിക്കുന്നു. തന്നിരിക്കുന്ന ഒരു നിയമത്തിനുള്ള ടാഗ്സ് കീ ഇല്ലെങ്കിലോ  ലിസ്റ്റ് ശൂന്യമാണെങ്കിലോ ഒരു നിയമത്തിന് ടാഗുകൾ ഉണ്ടാകില്ല.

എങ്ങനെ നിങ്ങൾക്ക് ടാഗുകൾ ഉപയോഗിക്കാമെന്നുള്ളത് ഇതാ:

* ഒരു തന്നിരിക്കുന്ന ടാഗ് ഉള്ള നിയമങ്ങളെ അപ്രാപ്തമാക്കാൻ നിങ്ങൾക്ക് `-T <tag>` ആർഗ്യുമെൻറ് ഉപയോഗിക്കാം. `-T` ഒന്നിലധികം തവണ വ്യക്തമാക്കാനും കഴിയും. ഉദാഹരണത്തിന്, "filesystem" , "cis" ടാഗുകളോടൊപ്പം എല്ലാ നിയമങ്ങളും സ്ക്കിപ്പ് ചെയ്യുന്നതിന്  `falco -T filesystem -T cis ...`ഉപയോഗിച്ച് നിങ്ങൾക്ക് ഫാൽക്കോ റൺ ചെയ്യാം. `-T` എന്നത് `-t` ഉപയോഗിച്ച് വ്യക്തമാക്കാൻ കഴിയില്ല.
* ഒരു തന്നിരിക്കുന്ന ടാഗ് ഉള്ള നിയമങ്ങളെ *മാത്രം* റൺ ചെയ്യാൻ നിങ്ങൾക്ക് `-t <tag>` ആർഗ്യുമെൻറ് ഉപയോഗിക്കാം. `-t` ഒന്നിലധികം തവണ വ്യക്തമാക്കാനും കഴിയും. ഉദാഹരണത്തിന്, "filesystem", "cis" എന്നീ ടാഗുകൾ ഉപയോഗിച്ച് മാത്രം ആ നിയമങ്ങൾ റൺ ചെയ്യുന്നതിന്, `falco -t filesystem -t cis ...` ഉപയോഗിച്ച് നിങ്ങൾക്ക് ഫാൽക്കോ റൺ ചെയ്യാം. `-t` എന്നത് `-T` അല്ലെങ്കിൽ `-D <pattern>` ഉപയോഗിച്ചോ വ്യക്തമാക്കാനാവില്ല ( regex എന്ന നിയമനാമത്താൽ നിയമങ്ങൾ അപ്രാപ്തമാക്കുക).

### നിലവിലെ ഫാൽക്കോ നിയമഗണത്തിനായുള്ള ടാഗുകൾ

We've also gone through the default ruleset and tagged all the rules with an initial set of tags. ഞങ്ങൾ ഡീഫോൾട്ട് നിയമഗണം പരിശോധിക്കുകയും ടാഗുകളുടെ പ്രാരംഭഗണത്തോടുകൂടിയ എല്ലാ നിയമങ്ങളെയും ടാഗുചെയ്യുകയും ചെയ്തിട്ടുണ്ട്. ഞങ്ങൾ ഉപയോഗിച്ച ടാഗുകൾ ഇതാ:

ടാഗ് | വിവരണം 
:---|:-----------
`filesystem` | വായന/എഴുത്ത് ഫയലുകളെ സംബന്ധിക്കുന്ന നിയമം 
`software_mgmt` | rpm, dpkg മുതലായ ഏതെങ്കിലുമൊരു സോഫ്റ്റ്വെയർ/പാക്കേജ് മാനേജ്മെൻറ് ഉപകരണത്തെ സംബന്ധിക്കുന്ന നിയമം 
`process` | ഒരു പുതിയ പ്രക്രിയ ആരംഭിക്കുന്നതിനെയോ അല്ലെങ്കിൽ ഒരു നിലവിലെ പ്രക്രിയയുടെ സ്ഥിതി മാറ്റുന്നതിനെയോ സംബന്ധിക്കുന്ന നിയമം 
`database` | ഡാറ്റാബേസുകളെ സംബന്ധിക്കുന്ന നിയമം 
`host` | കണ്ടെയ്നറുകൾക്ക് പുറത്ത് *മാത്രം* പ്രവർത്തിക്കുന്ന നിയമം 
`shell` | ആരംഭിക്കുന്ന ഷെല്ലുകളെ പ്രത്യേകമായി സംബന്ധിക്കുന്ന നിയമം 
`container` | കണ്ടെയ്നറുകൾക്കകത്ത് *മാത്രം* പ്രവർത്തിക്കുന്ന നിയമം 
`cis` | CIS ഡോക്കർ ബെഞ്ച്മാർക്കിനെ സംബന്ധിക്കുന്ന നിയമം 
`users` | ഉപയോക്താക്കളുടെ മാനേജ്മെൻറിനെയോ അല്ലെങ്കിൽ ഒരു റണ്ണിങ് പ്രക്രിയയുടെ വ്യക്തിത്വം മാറ്റുന്നതിനെയോ സംബന്ധിക്കുന്ന നിയമം 
`network` |നെറ്റ്വർക്ക് പ്രവർത്തനത്തെ സംബന്ധിക്കുന്ന നിയമം

നിയമങ്ങൾക്ക് അവ മുകളിൽ പറഞ്ഞവയിൽ ഒന്നിലധികം കാര്യങ്ങളെ സംബന്ധിക്കുന്നുണ്ടെങ്കിൽ  ഒന്നിലധികം ടാഗുകൾ ആകാം. ഫാൽക്കോ നിയമഗണത്തിലെ എല്ലാ നിയമത്തിനും നിലവിൽ കുറഞ്ഞത് ഒരു ടാഗെങ്കിലുമുണ്ട്.

## നിയമവ്യവസ്ഥ മികച്ച പ്രവൃത്തികൾ

To allow for grouping rules by event type, which improves performance, Falco prefers rule conditions that have at least one  operator, at the beginning of the condition, before any negative operators (i.e. `not` or `!=`). പ്രകടനം കൂടുതൽ മികച്ചതാക്കുന്ന, ഇവൻറ് തരം അനുസരിച്ച് നിയമങ്ങളെ തരംതിരിക്കുന്നത് അനുവദിക്കുന്നതിന്, വ്യവസ്ഥയുടെ തുടക്കത്തിൽ, ഏതൊരു നെഗറ്റീവ് ഓപ്പറേറ്ററുകൾക്കും മുൻപായി, കുറഞ്ഞത്  ഒരു `evt.type=` ഓപ്പറേറ്ററെങ്കിലും ഉള്ള നിയമവ്യവസ്ഥകളെ ഫാൽക്കോ തിരഞ്ഞെടുക്കുന്നു(ഉദാ: `not` അല്ലെങ്കിൽ `!=`). ഒരു വ്യവസ്ഥക്ക് ഒരു `evt.type=`  ഓപ്പറേറ്ററും ഇല്ലെങ്കിൽ, ഫാൽക്കോ ഇതുപോലൊരു മുന്നറിയിപ്പ് ലോഗുചെയ്യുന്നു:

```
Rule no_evttype: മുന്നറിയിപ്പ് (no-evttype):
proc.name=foo
     ഒരു evt.type നിയന്ത്രണങ്ങളും ഉൾപ്പെട്ടിട്ടില്ല, അതായത് എല്ലാ ഇവൻറ് തരങ്ങൾക്കും അത് റൺ ചെയ്യും.
     ഇതിന് പ്രധാനപ്പെട്ട ഒരു പ്രകടനപിഴയുണ്ട്. സാധ്യമെങ്കിൽ ഒരു evt.type നിയന്ത്രണം ചേർക്കുന്നത് പരിഗണിക്കുക.
```

വ്യവസ്ഥയുടെ അവസാനഭാഗത്ത് ഒരു നിയമത്തിന് ഒരു `evt.type` ഓപ്പറേറ്റർ ഉണ്ടെങ്കിൽ, ഫാൽക്കോ ഇതുപോലൊരു മുന്നറിയിപ്പ് ലോഗ് ചെയ്യുന്നു:

```
Rule evttype_not_equals: മുന്നറിയിപ്പ് (trailing-evttype):
evt.type!=execve
     വ്യവസ്ഥയുടെ തുടക്കത്തിൽ എല്ലാ evt.type നിയന്ത്രണങ്ങളും ഇല്ല,
     അഥവാ നെഗറ്റീവ് മാച്ച് ആണ് ഉപയോഗിക്കുന്നത് (അതായത് "not"/"!="),ചില evt.type നിയന്ത്രണങ്ങൾക്കായി.
     ഇതിന് ഒരു പ്രകടനപിഴയുണ്ട്, നിയമത്തിനെ പ്രത്യേക ഇവൻറ് തരങ്ങളിലേക്ക് പരിമിതപ്പെടുത്താനാകാത്തതിനാൽ. 
     എല്ലാ evt.type നിയന്ത്രണങ്ങളെയും നിയമത്തിൻറെ ആരംഭത്തിലേക്ക് മാറ്റുകയോ,
     സാധ്യമെങ്കിൽ നെഗറ്റീവ് മാച്ചുകളുടെ സ്ഥാനത്ത് പോസിറ്റീവ് മാച്ചുകളാക്കി മാറ്റുന്നതോ പരിഗണിക്കുക.
```

## പ്രത്യേകപ്രതീകങ്ങൾ ഒഴിവാക്കുന്നു

ചില സാഹചര്യങ്ങളിൽ, നിയമങ്ങൾക്ക് `(`, സ്പേസുകൾ മുതലായവ പോലുള്ള പ്രത്യേകപ്രതീകങ്ങൾ ഉൾക്കൊള്ളേണ്ടതായി വരും. ഉദാഹരണത്തിന്, നിങ്ങൾക്ക് `(systemd)` എന്നതിൻറെ ഒരു `proc.name` ന് വേണ്ടി തിരയേണ്ടതായി വരും, ചുറ്റുമുള്ള പാരെൻതെസെസ് ഉൾപ്പെടെ.

ഫാൽക്കോ, സിസ്ഡിഗ് പോലെ, ഈ പ്രത്യേകപ്രതീകങ്ങൾ പകർത്തുന്നതിന് `"` എന്നത് ഉപയോഗിക്കാൻ നിങ്ങളെ അനുവദിക്കുന്നു. ഇതാ ഒരു ഉദാഹരണം:

```yaml
- rule: Systemd ചെയ്യുന്ന ഏതൊരു ഓപ്പൺ പ്രവൃത്തിയും
  desc: Systemd ചെയ്യുന്ന എല്ലാ ഓപ്പൺ പ്രവൃത്തിയും കണ്ടുപിടിക്കുന്നു.
  condition: evt.type=open and proc.name="(systemd)" or proc.name=systemd
  output: "File opened by systemd (user=%user.name command=%proc.cmdline file=%fd.name)"
  priority: WARNING
```

ലിസ്റ്റുകളിൽ ഇനങ്ങൾ ഉൾപ്പെടുത്തുമ്പോൾ, ഡബിൾക്വോട്ടുകൾ നിങ്ങളുടെ YAML ഫയലിൽ നിന്നും സിംഗിൾ ക്വോട്ടുകളുപയോഗിച്ച് ക്വോട്ടഡ് സ്ട്രിങ് ആവരണം ചെയ്തുകൊണ്ട് വ്യാഖ്യാനിച്ചതല്ലെന്ന് ഉറപ്പുവരുത്തുക. ഇതാ ഒരു ഉദാഹരണം:

```yaml
- list: systemd_procs
  items: [systemd, '"(systemd)"']

- rule: Systemd ചെയ്യുന്ന ഓപ്പൺ പ്രവൃത്തി
  desc: ystemd ചെയ്യുന്ന എല്ലാ ഓപ്പൺ പ്രവൃത്തിയും കണ്ടുപിടിക്കുന്നു.
  condition: evt.type=open, proc.name (systemd_procs) എന്നതിൽ
  output: "File opened by systemd (user=%user.name command=%proc.cmdline file=%fd.name)"
  priority: WARNING
```

## അവഗണിച്ച സിസ്റ്റം കോളുകൾ

പ്രകടനപരമായ കാരണൾക്കായി, ചില സിസ്റ്റം കോളുകൾ നിലവിൽ ഫാൽക്കോ അവ പ്രോസസ്സ് ചെയ്യുന്നതിന് മുൻപ് നിരാകരിക്കുന്നു. നിലവിലെ ലിസ്റ്റ് ഇതാ:

```
access alarm brk capget clock_getres clock_gettime clock_nanosleep clock_settime close container cpu_hotplug drop epoll_create epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 exit_group fcntl fcntl64 fdatasync fgetxattr flistxattr fstat fstat64 fstatat64 fstatfs fstatfs64 fsync futex get_robust_list get_thread_area getcpu getcwd getdents getdents64 getegid geteuid getgid getgroups getitimer getpeername getpgid getpgrp getpid getppid getpriority getresgid getresuid getrlimit getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr infra io_cancel io_destroy io_getevents io_setup io_submit ioprio_get ioprio_set k8s lgetxattr listxattr llistxattr llseek lseek lstat lstat64 madvise mesos mincore mlock mlockall mmap mmap2 mprotect mq_getsetattr mq_notify mq_timedreceive mq_timedsend mremap msgget msgrcv msgsnd munlock munlockall munmap nanosleep newfstatat newselect notification olduname page_fault pause poll ppoll pread pread64 preadv procinfo pselect6 pwrite pwrite64 pwritev read readv recv recvmmsg remap_file_pages rt_sigaction rt_sigpending rt_sigprocmask rt_sigsuspend rt_sigtimedwait sched_get_priority_max sched_get_priority_min sched_getaffinity sched_getparam sched_getscheduler sched_yield select semctl semget semop send sendfile sendfile64 sendmmsg setitimer setresgid setrlimit settimeofday sgetmask shutdown signaldeliver signalfd signalfd4 sigpending sigprocmask sigreturn splice stat stat64 statfs statfs64 switch sysdigevent tee time timer_create timer_delete timer_getoverrun timer_gettime timer_settime timerfd_create timerfd_gettime timerfd_settime times ugetrlimit umask uname ustat vmsplice wait4 waitid waitpid write writev
```

 `-i` ഉപയോഗിച്ച് റൺ ചെയ്യുമ്പോൾ, ഫാൽക്കോ ഇവൻറുകളുടെ/ സിസ്കോളുകളുടെ ഗണം അവഗണിക്കപ്പെട്ടതായി പ്രിൻറുചെയ്യുകയും എക്സിറ്റ് ചെയ്യുകയും ചെയ്യുന്നു. മുകളിലെ ലിസ്റ്റിലെ സിസ്റ്റം കോളുകൾ ഉൾപ്പെടെ, എല്ലാ ഇവൻറുകൾക്കും എതിരായി നിങ്ങൾക്ക് ഫാൽക്കോ റൺ ചെയ്യണമെന്നുണ്ടെങ്കിൽ, നിങ്ങൾക്ക് `-A` ഫ്ലാഗ് ഉപയോഗിച്ച് ഫാൽക്കോ റൺ ചെയ്യാം.

